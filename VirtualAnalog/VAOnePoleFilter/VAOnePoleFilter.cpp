//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>
#include <CFilter.h>

// declaration of chugin constructor
CK_DLL_CTOR(vaonepolefilter_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(vaonepolefilter_dtor);

// example of getter/setter
CK_DLL_MFUN(vaonepolefilter_setParam);
CK_DLL_MFUN(vaonepolefilter_getParam);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(vaonepolefilter_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT vaonepolefilter_data_offset = 0;


// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class VAOnePoleFilter : public CFilter
{
public:
    // constructor
    VAOnePoleFilter( t_CKFLOAT fs)
    {
        // --- init defaults to simple 
        //	   LPF/HPF structure
        m_dAlpha = 1.0;
        m_dBeta = 0.0;
        m_dZ1 = 0.0;
        m_dGamma = 1.0;
        m_dDelta = 0.0;
        m_dEpsilon = 0.0;
        m_da0 = 1.0;
        m_dFeedback = 0.0;

        // --- always set the default!
        m_uFilterType = LPF1;

        // --- flush storage
        reset();
    }

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        // default: this passes whatever input is patched into Chugin
        return doFilter( in) ;
    }

    // recalc coeffs
    public void update()
    {
        // base class does modulation, changes m_fFc
        CFilter::update();

        double wd = 2*pi*m_dFc;          
        double T  = 1/m_dSampleRate;             
        double wa = (2/T)*tan(wd*T/2); 
        double g  = wa*T/2;            

        m_dAlpha = g/(1.0 + g);
    }

    // do the filter
    double doFilter( t_CKFLOAT xn)
    {
        // return xn if filter not supported
        if(m_uFilterType != LPF1 && m_uFilterType != HPF1)
            return xn;

        // for diode filter support
        xn = xn*m_dGamma + m_dFeedback + m_dEpsilon*getFeedbackOutput();
        
        // calculate v(n)
        double vn = (m_da0*xn - m_dZ1)*m_dAlpha;

        // form LP output
        double lpf = vn + m_dZ1;

        // update memory
        m_dZ1 = vn + lpf;

        // do the HPF
        double hpf = xn - lpf;

        if(m_uFilterType == LPF1)
            return lpf;
        else if(m_uFilterType == HPF1)
            return hpf;

        return xn; // should never get here
    }
	// provide access to set feedback input
	void setFeedback(double fb){m_dFeedback = fb;}

	// provide access to our feedback output
	// m_dFeedback & m_dDelta = 0 for non-Diode filters
	double getFeedbackOutput(){return m_dBeta*(m_dZ1 + m_dFeedback*m_dDelta);}

	// -- CFilter Overrides ---
	virtual void reset(){m_dZ1 = 0; m_dFeedback = 0;}

	// Trapezoidal Integrator Components
	double m_dAlpha;			// Feed Forward coeff

	// -- ADDED for Korg35 and Moog Ladder Filter ---- //
	double m_dBeta;

	// -- ADDED for Diode Ladder Filter  ---- //
	double m_dGamma;		// Pre-Gain
	double m_dDelta;		// FB_IN Coeff
	double m_dEpsilon;		// FB_OUT scalar
	double m_da0;			// input gain

	// note: this is NOT being used as a z-1 storage register!
	double m_dFeedback;		// our own feedback coeff from S 

private:
    // instance data
    float m_param;

protected:
    double m_dZ1;
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( VAOnePoleFilter )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "VAOnePoleFilter");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "VAOnePoleFilter", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, vaonepolefilter_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, vaonepolefilter_dtor);
    
    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, vaonepolefilter_tick, NULL, 1, 1);
    
    // NOTE: if this is to be a UGen with more than 1 channel, 
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    // example of adding setter method
    QUERY->add_mfun(QUERY, vaonepolefilter_setParam, "float", "param");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, vaonepolefilter_getParam, "float", "param");
    
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    vaonepolefilter_data_offset = QUERY->add_mvar(QUERY, "int", "@vaopf_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(vaonepolefilter_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, vaonepolefilter_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    VAOnePoleFilter * bcdata = new VAOnePoleFilter(API->vm->get_srate());
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, vaonepolefilter_data_offset) = (t_CKINT) bcdata;
}


// implementation for the destructor
CK_DLL_DTOR(vaonepolefilter_dtor)
{
    // get our c++ class pointer
    VAOnePoleFilter * bcdata = (VAOnePoleFilter *) OBJ_MEMBER_INT(SELF, vaonepolefilter_data_offset);
    // check it
    if( bcdata )
    {
        // clean up
        delete bcdata;
        OBJ_MEMBER_INT(SELF, vaonepolefilter_data_offset) = 0;
        bcdata = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(vaonepolefilter_tick)
{
    // get our c++ class pointer
    VAOnePoleFilter * c = (VAOnePoleFilter *) OBJ_MEMBER_INT(SELF, vaonepolefilter_data_offset);
 
    // invoke our tick function; store in the magical out variable
    if(c) *out = c->tick(in);

    // yes
    return TRUE;
}


// example implementation for setter
CK_DLL_MFUN(vaonepolefilter_setParam)
{
    // get our c++ class pointer
    VAOnePoleFilter * bcdata = (VAOnePoleFilter *) OBJ_MEMBER_INT(SELF, vaonepolefilter_data_offset);
    // set the return value
    RETURN->v_float = bcdata->setParam(GET_NEXT_FLOAT(ARGS));
}


// example implementation for getter
CK_DLL_MFUN(vaonepolefilter_getParam)
{
    // get our c++ class pointer
    VAOnePoleFilter * bcdata = (VAOnePoleFilter *) OBJ_MEMBER_INT(SELF, vaonepolefilter_data_offset);
    // set the return value
    RETURN->v_float = bcdata->getParam();
}
